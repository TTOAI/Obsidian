
- Components of computer: processor(datapath, control), memory, input, output
- ISA: Instruction Set Architecture
- RISC: Reduced Instruction Set Computer
- ARM: Advanced RISC Machine
- CISC: Complex Instruction Set Computer

- 2's complement로 표현할 수 있는 수: ==-2^(n-1) ~ 2^(n-1) - 1==
- MIPS는 big endian: 저장할 메모리 위치의 가장 작은 주소에 MSB가 저장됨

- ==basic block==
	- beginning 외에는 branch targets가 없고, end 외에는 embedded branches가 없다
- value만을 가지고 value의 type과 sign을 결정할 수 없음
	- type과 sign은 그 value를 이용하는 instruction에 의해 결정됨

- r-format: 6 5 5 5 5 6
- i-format: 6 5 5 16
- j-format: 6 26

- $PC를 이용한 instruction의 execution
	- $PC에서 instruction을 fetch함
	- $PC를 4만큼 증가시킴
	- instruction을 decode함
	- instruction을 execute함
- ==caller-save==, ==callee-save==
	- ==마음대로== 쓰고 함수 호출 전에 save: caller-save($ra, $a, ==\$t==)
	- ==쓰기 전에 save==하고 return 전에 restore: callee-save($s)
- $fp: base of the current stack frame
- $sp: top of the stack
- ==function prologue==: assembly code to populate the stack frame
	- ==addi== sp sp 음수
	- (함수 호출==할 것 같으면==) $ra, $a, $t save
	- (쓸 거면) $s save
- ==function epilogue==: pop stack frame
	- ==addi== sp sp 양수
	- (==실제로== 함수 호출했으면) $ra, $a, $t restore
	- (썼으면) $s restore
- argument가 4개 초과?
	- 함수를 호출할 때 스택에 초과 argument들을 저장해두고 함수를 실행할 때 스택에서 불러오도록 하면 됨
- data type이 integer가 아니면? 
	- 복잡한 data type들은 pointer로 넘겨줌
- strcpy(char * dst, char * src) 구현
	- * dst in $a0, * src in $a1
	- again:
			lbu t0 0(a1)
			beq t0 zero ret
			sb t0 0(a0)
			addi a0 a0 1
			addi a1 a1 1
			j again
	- ret:
			sb t0 0(a0)
			jr ra
- strlen(char * x) 구현
	- * x in $a0
			add v0 zero zero
	- again:
			lbu t0 0(a0)
			beq t0 zero ret
			addi v0 v0 1
			addi a0 a0 1
			j again
	- end:
			jr ra

- backward compatibility: 하드웨어나 소프트웨어가 이전 버전과 호환되는 능력

- add: ==n-bit ripple-carry adder==
- subtract: add 2’s complement
- optimized multiplier: compare, add, right shift
	- multiplier를 하위 16bit에 넣음
	- 반복
		- multiplier의 LSB부터 한 bit씩 확인함
		- multiplier의 bit가 1이면,
		  상위 16bit에 multiplicand를 더함
		  전체를 오른쪽으로 1bit shift함
		- multiplier의 bit가 0이면,
		  전체를 오른쪽으로 1bit shift함
	- multiplier를 모두 확인하면 종료함
	- 남아있는 숫자가 product
- optimized dvisor: compare, subtract, left shift
	- dividend를 하위 16bit에 넣음
	- 반복
		- 왼쪽으로 1bit shift함
		- divisor와 상위 16bit를 비교함
		- divisor가 크면,
		  LSB를 0로 set함
		- divisor가 상위 16bit보다 작거나 같으면,
		  상위 16비트에서 divisor만큼을 뺌
		  LSB를 1로 set함
	- dividend를 모두 비교하면 종료함
	- 상위 16bit가 remainder, 하위 16bit가 quotient
- division은 subtraction을 수행해야 하므로 multiplier처럼 더 빠르게 수행할 수 없음

- fixed-point notation
- IEEE floating point (single-precision floating point)
	- sign bit: 1bit, exponent: ==8bits==, fraction: 23bits
	- exponent = actual exponent + ==127==
- IEEE floating point 구분 (single-precision floating point)
	- exponent = 0, fraction = 0 -> 0
	- exponent = 0, fraction = nonzero -> denormalized number
		- 절댓값이 아주 작은 수를 표현
		- exponent는 ==-126==으로 고정
		- sinificand의 정수부는 0
	- exponent = 0b11..11, fraction = 0 -> +-infinity
	- exponent = 0b11..11, fraction = nonzero -> NaN(Not a Number)
- smallest absolute value
	- exponent = 0b00000001, fraction = 0b00..00
	- ==+-1.0 * 2^(-126)==
- largest absolute value
	- exponent = 0b11111110, fraction = 0b11..11
	- ==+-2.0 * 2^127==
- double-precision floating point
	- sign bit: 1bit, exponent: ==11bits==, fraction: 52bits
	- exponent = actual exponent + ==1023==
- 16bit representation
	- float16
		- sign bit: 1bit, exponent: ==5bits==, fraction: 10bits
	- Bfloat16
		- sign bit: 1bit, exponent: ==8bits==, fraction: 7bits
- FP addition
	- exponent 큰 쪽으로 맞춤
	- significand 더함
	- normalize, overflow 확인
- FP multiplication
	- exponent 큰 쪽으로 맞춤
	- significand 곱함
	- normalize, overflow 확인

- PA1
	- r-format에서 instruction 만들기
		- instruction |= opcode << 26;
		  instruction |= rs << 21;
		  instruction |= rt << 16;
		  instruction |= rd << 11;
		  instruction |= shamt << 6;
	- i-format에서 음수 처리
		- instruction |= const_addr & 0xFFFF;

- PA2
	- j-format에서 target address 만들기
		- target_addr |= ((opcode & (0b1111 << 2)) << 26);
		  target_addr |= (((instr & (0xFFFFFFFF >> 6))) << 2);
