# Process
- An instance of a program in execution
	- class -> program (on disk), object -> process
- 하나의 program이 여러 process가 될 수 있음
	- 여러 user가 같은 program을 쓰는 경우
- 각 process는 process ID를 가지고 있음
- ![[Pasted image 20240928132451.png]]
- Code: program code
- Data: global variables
- Stack: temporary data (Function parameters, return addresses, local variables), SP register
- Heap: memory dynamically allocated during run time

# Process State Transitions

- ![[Pasted image 20240928134846.png]]

# Process Creation

- process(parent)가 다른 process(children) 생성 가능

- fork()
	- 현재 process를 cloning해서 새로운 process를 만듦
	- child는 parent의 address space를 복제함
	- 두 process 모두 코드의 다음 instruction을 계속해서 실행함
	- child 가 생성된 후,
		- parent와 parallel하게 실행함
		- parent가 child가 종료할 때까지 기다림
			- wait()
		- child는 새로운 program을 가짐
	- fork()의 반환값
		- parent: child의 PID
		- child: 0

- exec()
	- 현재 process image를 새로운 process image로 교체
		- image: process의 메모리 공간
	- 현재 완전히 새로운 메모리 공간이 할당됨
	- 대체할 executable file과 전달할 argument를 지정
	- Windows: CreateProcess() = fork() + exec()

# Process Termination

- Voluntary
	- normal exit
	- error exit

- Involuntary
	- fatal error
		- segmentation fault
		- protection fault
		- exceed allocated resources
	- 다른 process에 의해 killed
		- signal을 받음

- process가 exit()을 통해 OS에 종료 요청
	- parent에 status data를 반환
	- OS가 resource 회수

- 다른 process의 abort() 혹은 kill()에 의해 종료
	- signal을 통해 처리됨

- process는 wait()을 통해 child process의 종료를 기다릴 수 있음
	- child의 pid, status info가 반환됨

- process는 waitpid()를 통해 다른 어느 process의 종료를 기다릴 수 있음

# Process Termination

- zombie process
	- process가 종료되었지만 parent/다른 process가 아직 wait()/waitpid()를 호출하지 않음
	- process의 실행 결과가 회수되지 않은 채 남아있음
- Orphan process
	- parent가 wait()을 호출하지 않은 채 exit함
	- 몇몇 OS는 orphan process를 남기지 않기 위해 cascading termination을 사용함
		- 모든 하위 process를 종료
	- reparenting: (In UNIX and Linux) init/systemd process가 wait()을 주기적으로 호출하여 orphan process를 child로 만듦

# Implementing Processes
- Process Control Block (PCB)
	- process에 대한 모든 정보를 담고 있음
	- linux: task_struct 구조체
