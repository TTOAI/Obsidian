
- 알고리즘의 다섯 가지 요구 조건
	- 입력
	- 출력
	- 명확성
	- 유한성
	- 유효성

- 양의 정수 x, y 및 z에 대하여 x^n+y^n = z^n이 되는 n의 최댓값은 2인가?
	- 명확성 만족 안 함; instruction이 아님

- 5를 0으로 나눠 x에 저장하고 10번 명령문으로 분기하라
	- 유효성 만족 못 함; 5/0 못 함

![[Pasted image 20240424153114.png]]
- transposing a matrix
	1. a[].col ==  0인 term들부터 마지막 colunm인 term들까지 차례대로  b에 저장 (currentb == 1부터 차례대로 저장)
	2. 각 경우마다 a의 colunm을 처음부터 끝까지 스캔
	   (col이 같은 경우 row가 큰 게 이미 밑에 있으므로 따로 순서를 바꿀 필요 없음)
	   
	시간복잡도: a[0].value * a[0].col, O(n\*m)

![[Pasted image 20240424153136.png]]
- fast transposing a matrix
	- rowTerms[]: b의 각 row(a의 각 colunm)마다 term의 개수를 저장
	- startingPos[]: b의 각 row(a의 각 colunm)마다 몇 번째 term으로 시작하는지 저장
	
	1. rowTerms[]를 0으로 초기화
	2. a의 term들을 모두 차례대로 스캔하며 각 colunm마다 term의 개수를 rowTerms에 저장
	3. a의 각 colunm에 대해 stratingPos[]에 rowTerms[]를 누적하여 저장(startingPos[0] == 1)
	4. a의 term을 차례대로 스캔하며 startingPos[]를 참고해 b의 각 자리에 바로 저장
	
	시간복잡도: a[0].col + a[0].value, O(n+m)

![[Pasted image 20240424153210.png]]
- nfind
	- lasts: string의 마지막 index
	- lastp: pattern의 마지막 index
	- start: 일치하는 string부분의 시작 index (0부터 ++)
	- endmatch: 일치하는 string부분의 마지막 index (lastp부터 ++)
	
	1. start와 endmatch를 \*s 위에서 옮겨가며
	   s[endmatch] == pat[lastp]를 찾음
	2. \*pat의 첫 문자와 \*s의 start부터 서로 일치하는지 확인
	3. 일치하면 start(일치하는 부분의 시작 index) 반환
	
	시간복잡도: strlen(s) * strlen(pat), O(n\*m)

![[Pasted image 20240424153343.png]]
![[Pasted image 20240424153322.png]]
- KMP algorithm
	- failure function
		- pat의 index 0부터 function값의 index까지 패턴이 마지막에 반복됨
		- function값의 index까지는 string과 동일함을 이미 확인했으므로 그 다음 index부터 확인하면 됨
		
		- j == 0부터 pat의 마지막 문자까지 스캔
		- index 0의 function값은 -1
		-  index j와 index i( == j-1의 function값)+1을 비교
			- 동일하면 j의 function값 = i + 1
			- 다르면
				- index i의 function값 확인
					- -1이 아니면 function값의 index까지는 동일하다는 의미(failure function의 정의)
					  -> index i의 function값을 i로 놓고 다시 비교
					- -1이면
						- function값은 0 또는 -1
		
		시간복잡도: strlen(pat), O(n)
		
	- pattern matching
		- string의 index는 i, pat의 index는 j
		- 차례대로 비교
			- 같으면 i++, j++
			- 다르면
				- j == 0이면 i++
				- j = failure[j-1]+1
			- 다시 비교
		- i가 단조 증가함
		
		시간복잡도: strlen(string), O(m)
	
	총 시간복잡도: strlen(pat) + strlen(string), O(n+m)

![[Pasted image 20240424154006.png]]
- infix to postfix
	- operand는 바로 출력
	- incoming operator 기준으로
	  우선순위 높으면 push
	  우선순위 낮거나 같으면 pop // push할 때까지 반복
	- ) 만나면 (까지 모두 pop
	- 마지막 operand까지 확인했으면 나머지 모두 pop
	
	생각해서 바꿀 때: 높은 우선순위(먼저 수행해야 하는 연산) 먼저 출력

![[Pasted image 20240424154022.png]]
- evaluating postfix
	- operand는 push
	- operator면
		- binary: 첫 번째 pop: op2, 두 번째 pop: op1
		- unary: pop 한 번
		- 연산 수행 결과 push

![[Pasted image 20240424154059.png]]
- list insertion
	- insert(listPointer \*first, listPointer x)
		- \*first: 처음 노드의 포인터의 포인터 (노드 포인터의 값을 바꾸므로 포인터로 인자 전달)
		- x: 삽입 노드의 이전 노드
	
	- 삽입 노드 초기화
	- 이전 노드 초기화
	- if(==\*first==) else
	- 노드가 하나밖에 없으면 x가 \*first에
	- 노드가 없으면 삽입 노드가 \*first에

![[Pasted image 20240424154130.png]]
- list delete
	- delete(listPointer \*first, listPointer trail, listPointer x)
		- \*first: 처음 노드의 포인터의 포인터
		- trail: 삭제 노드의 이전 노드
		- x: 삭제 노드
	
	- 이전 노드 초기화
	- if(==trail==) else
	- 노드가 하나밖에 없으면 x가 \*first

- add two polynomials
	- attach(float coefficient, int exponent, polyPointer\*ptr)
		- (\*ptr)→link = temp;
		- \*ptr= temp;
	- \*ptr: 마지막 노드의 노드 포인터의 포인터
	
	시간복잡도: O(m+n)

![[Pasted image 20240424154356.png]]
- erasing polynomials
	- erase(polyPointer \*ptr)
		- \*ptr부터 차례대로 free

![[Pasted image 20240424154447.png]]
![[Pasted image 20240424154519.png]]
![[Pasted image 20240424154549.png]]
- circular list
	- avail list
		- 제일 앞 노드는 avail이 가리킴
		- 앞에서 빼거나 붙이는 형식
	- cerase
		- cerase(polyPointer\* ptr)
			- 첫 번째 노드가 avail list의 첫 번째 노드를 가리키게 함 ((\*ptr)->link = avail;)
			- 두 번째 노드를 avail로 바꿈 (avail = temp;)

![[Pasted image 20240424154618.png]]
![[Pasted image 20240424154643.png]]
- zero polynomial (with a header node)
	- cpadd(polyPointer a, polyPointer b)
		- a, b 결국 header node(expon == -1)로 돌아옴

- tree terminology
	- degree: subtree 개수
	- ancestors, descendants

- K-ary tree representation
	- \# of nodes = n, n >= 1
	- possible node structure for a tree of degree k
		 - data - child 1 - child 2 - ... - child k
	- \# of child fields = nk
	- \# of non-empty child fields = n-1
	- \# of empty child fields = nk-(n-1)

- Left child-right sibling representation
	- node structure
		        data
			left child | right sibling

- Left child-right sibling -> Binary tree

- Binary tree
	- node의 최소 개수: 0
	- level i의 node의 최대 개수: 2^(i-1)
	- depth k인 binary tree의 node의 최대 개수: 2^k -1
	- children의 순서 중요함
		- ex) left(right) subtrees만 가진 binary tree

- Binary tree의 종류
	- Skewed binary tree
	- Full binary tree: (2^k - 1) nodes
	- Complete binary tree: 왼쪽부터 차례대로 채워진 binary tree

- complete tree
	- index i인 node
	- parent: i/2의 몫
	- leftChild: 2i
	- rightChild: 2i+1

- tree traversal
	- LVR: inorder, LRV: postorder, VLR: preorder

![[Pasted image 20240424154731.png]]
- iterative inorder traversal
	- stack 이용, DFS
	
	- 반복
		- left child의 마지막까지 push하며 이동
		- empty stack인지 체크
		- pop 후 출력
		- right child로 이동
	
	- DFS의 기본 아이디어:
		- 왼쪽으로 쭉 내려가기
		- 오른쪽으로 갈 수 있으면 한 칸 이동
		- 왼쪽으로 또 쭉 내려가고, ...

![[Pasted image 20240424154753.png]]
- level order traversal
	- heap 이용, BFS
	
	- 반복
		- 출력
		- left, right child push
		- pop

![[Pasted image 20240424154831.png]]
- threaded binary tree
	- insucc(threadedPointer tree)
		- 그 다음 순서의 node(successor)를 찾는 함수
		
		- right child로 이동
			- right child가 있으면 제일 마지막 left child까지 이동, 노드 리턴
			- right child가 없으면 right thread(그 다음 순서)로 이동, 노드 리턴
	
	- threaded의 thread == stack의 pop

![[Pasted image 20240424154912.png]]
- inserting a node as a right child
	- 삽입 노드 초기화
	- 이전 노드 초기화
	- right child 있으면 insucc()
	- 삽입 노드 그 다음 순서 leftTread 초기화

- heap
	- priority queue 구현을 위해 사용
	- max heap
		- max tree 이면서 complete binary tree
		- max tree: 부모 node가 value가 자식 node의 key value보다 무조건 크거나 같은 값을 갖는 tree
	
	시간복잡도: insertion, deletion 모두 O(log(2)n)
