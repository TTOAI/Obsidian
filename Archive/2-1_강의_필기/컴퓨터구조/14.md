
- Pipeline Hazards:
	  모종의 이유로 다음 instruction의 수행을 막게 되는 상황
	-  hazard가 해결될 때까지 다음 instruction의 수행을 막음(stall the pipeline)
	  -> performance가 낮아짐
	- 회로를 수정해서 pipeline stall을 해결할 수 있으면 수정함
	
	- Structure hazards
		: ID, WB 단계에서 register 사용이 겹침
		1. 각 단계를 반으로 쪼개서 1 cycle동안 WB->ID 순으로 register에 접근하도록 함
		: IF, MEM 단계에서 메모리 사용이 겹침
		1. instruction, data를 위한 두 port를 사용해서 메모리 접근
	
	- Data hazards
		: 이전 instruction에 의해 값이 바뀌는 register를 사용함
		1. Read-after-Write (RAW), (true) dependency
			: pipeline을 ==2 cycle stall==해서 이전 instruction이 WB을 수행할 때 ID를 수행함
			- sturucture hazards 해결 안 했으면 ==3 cycle stall== 해야 함
		2. forwarding, bypassing
			: datapath에 connections를 추가해서 바로 쓸 수 있도록 함
			- r-format
				- 이후 2개의 instruction에 대해서만 확인
				- EX/MEM에서 EX로, MEM/WB에서 EX로
				- ==stall 없음==
			- lw
				- 이후 1개의 instruction에 대해서만 확인
				- MEM/WB에서 EX
				- ==1 cycle stall==
				  -> lw에 의해 값이 바뀌는 register를 바로 다음 instruction에 사용하지 않도록 instructions를 재배치함으로써 stall 해결 가능
	
	- Control hazards
		: branch에 의해 생기는 hazards
		1. branch outcome(decision + target address)이 결정되기 전까지 stall함 
			- branch outcome이 MEM stage에서 결정되므로 MEM stage에서 pc값이 바뀐 후 그 다음 cycle부터 instruction fetch가 다시 가능함
			  -> ==3 cycle stall==
			- branch outcome 계산을 EX stage가 아니라 ID stage에서 하도록 함
				- branch에서 비교하는 두 레지스터가 ALU instruction의 destination일 경우
				  -> branch의 ID stage가 ALU instruction의 EX stage 이후에 위치하도록 stall
				- branch에서 비교하는 두 레지스터가 lw instruction의 destination일 경우
				  -> branch의 ID stage가 lw instruction의 MEM stage 이후에 위치하도록 stall
		2. branch prediction
			- Static branch prediction
				- branch를 만났을 때 주변의 상황과 관계 없이 predict를 함
				- MIPS pipeline
					: not taken을 기본으로 하는 static branch prediction 사용
			- Dynamic branch prediction
				- hardware가 실제 branch의 behavior를 측정해서 future behavior를 가정함
				- deeper and superscalar pipelines에서는 branch penalty가 크므로 modern architectures에서는 dynamic prediction을 사용
			- prediction이 맞든 틀리든 pipeline의 correctness와는 관련 없음
