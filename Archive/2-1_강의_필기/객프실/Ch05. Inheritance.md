
## part1. Inheritance Basics
- extends 키워드 사용
- method, field 추가 가능
- subclass constructor
	- superclass의 생성자를 불러옴
	- 명시적으로 호출하지 않으면, superclass의 no-arg constructor(기본생성자)를 불러옴
	- superclass에 기본생성자가 없음
	  -> 매개변수가 있는 생성자가 있음
	  -> subclass의 생성자에서 superclass의 생성자를 명시적으로 call하지 않는 경우, 불러 올 기본생성자가 없으므로 ==compile-error==
	  -> subclass의 생성자에서 superclass의 생성자를 명시적으로 호출해야 함
-  subclass는 superclass의 private member에 접근할 수 없음
   -> superclass의 public method를 통해 접근해야 함 (super 안 붙여도 됨)
  - overriding methods
	  - inherited method 변경
		  - ex) superclass의 private 변수를 바로 사용하지 못하므로  method 내용 변경
	  - super 키워드를 이용하여 overring하는 method에 superclass의 원래 method 사용 가능

## part2. Polymorphism
- subclass의 객체는 superclass의 객체라고도 할 수 있음
  -> is-a relationship
- superclass의 객체를 쓸 곳에 subclass의 객체를 써도 됨
  -> substitution principle
- polymorphism: 서로 다른 유형의 객체에 대해 단일 인터페이스를 제공함, 코드의 ==유연성과 재사용성==을 향상시킬 수 있음
- ==subtype polymorphism==
	- ==is-a relationship==: class의 참조 변수는 그것의 subclass의 instances를 나타낼 수도 있음
	- ==method overriding==: superclass의 methods는 subclasses에 overriding될 수 있음
	- ==dynamic binding==: 변수가 참조하는 ==객체의 유형에 따라== 실제 사용될 method가 결정됨, ==overriding==을 위한 binding, runtime에 수행됨
		- private, static, final이 아닌 method에 대해 사용
		  -> private, static, final일 경우 override 불가하므로 compile time에 binding (static binding)
- subtype polymorphism의 장점
	- 쉽게 ==확장 가능==한 시스템을 설계하고 구현할 수 있음
	- 간단하고 컴팩트한 프로그램을 작성할 수 있음
- method call 이해
	- obj.f(args); obj is declared to be of type C
	- step1. compile time
		- ==변수의 타입에 따라== 해당 클래스와 상위 클래스에서 이름이 같은 method를 찾음
		  -> 변수의 타입이 C이므로 C와 C의 상위 클래스에서 찾음
		- 매개변수 타입과 인자 타입을 비교해 method를 결정함
		  (overloading 해결)
			- method를 매치할 수 없으면 ==compile-error==
			- 같으면 overriding, runtime 시점에 method가 결정됨
			- method가 private, static, final로 선언되었다면 override가 불가능하여 compile 시점에 method가 결정됨
	- step2. runtime
		- override된 method에 대해 정확한 method를 선택함
		  (dynamic binding)
- casting
	- superclass reference는 subclass 객체를 참조하고 있다고 하더라도 subclass variable에 assign될 수 없음
	- 하지만 명시적으로 cast하는 경우 assign 가능 (==downcasting==)
	  -> 객체가 실제로 subclass가 아닌 경우 ==ClassCastException==
	  -> ==instanceof==로 확인 가능
- overriding
	- return type이 다를 수 있음
	- 접근 제한자는 상위 클래스의 메소드보다 넓은 범위여야 함
	- @override 를 통해 compiler가 확인하게 할 수 있음
	  -> override가 아닐 경우 ==compile-error==
	- protected
		- subclass의 특성에 따라 적절히 변경해주어야 하는 상황을 고려한 메소드
	- final
		- final class 상속 불가
		- final method override 불가
