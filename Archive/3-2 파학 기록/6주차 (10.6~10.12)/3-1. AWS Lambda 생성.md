- Lambda 함수 생성 시 IAM role 생성됨
- 이후 Lambda 함수 목적에 맞게 IAM role 수정

---

- Lambda 함수 기본 소스코드
```python
import json

def lambda_handler(event, context):
    # TODO implement
    return {
        'statusCode': 200,
        'body': json.dumps('Hello from Lambda!')

    }
```

---

### 이벤트 JSON

- Lambda에 전달되는 입력 데이터(JSON)
- event 객체에 저장됨
- 실제 배포 후에는 S3, EventBridge, API Gateway 등 트리거가 자동으로 event JSON을 생성해서 Lambda로 넘김

---

### Lambda Layer 생성(1) - requirements.txt

- requirements.txt를 이용하여 라이브러리 폴더 생성
- 폴더 이름은 런타임 유형과 같아야 함 (ex. python)
```bash
mkdir python
pip install -r requirements.txt -t python/
```
- zip 파일로 압축 후 lambda layer로 추가
- layer 생성 시 이름, zip 파일, 호환 아키텍처, 호환 런타임 지정
	- lambda 함수의 아키텍처, 런타임과 동일하게 지정

---

### Lambda 함수 트리거 추가

- EventBridge 추가

---

### Lambda 함수 소스코드 작성

- `lambda_handler`를 main 함수 취급
- 원하는 코드를 Class화시켜서 `lambda_handler`코드에 import

---

### Lambda Layer 생성(2) - Chromedriver + Headless Chromium을 Layer로 미리 넣기

- AWS Lambda 실행 환경은 읽기 전용 파일시스템으로 설정되어 있음

```python
self.driver = webdriver.Chrome(service=Service(ChromeDriverManager().install()), options=options)
```

- 크롬 드라이버를 Lambda 실행 환경에 다운로드할 수 없기 때문에 오류가 남
- `webdriver-manager`를 쓰는 대신 미리 Layer로 드라이버와 브라우저를 포함시켜야 함

- 시도해본 결과...
- Layer에 포함시켜야 할 Chrome 브라우저 바이너리 파일을 찾지 못함

- Playwright를 사용하면 Selenium과 달리 일반 Chrome 브라우저가 아닌 Playwright 전용 브라우저를 사용할 수 있음
- Playwright 전용 브라우저에는 Playwright 전용 엔진이 포함됨
- 또한 Playwright는 자체 통신 엔진(Protocol Driver)을 포함하고 있어 외부 드라이버가 필요 없음

- Selenium 구조
```
Python (Selenium)
   ↓  (HTTP JSON 통신)
ChromeDriver.exe
   ↓  (DevTools Protocol)
Chrome 브라우저
```

- Playwright 구조
```
Python (Playwright)
   ↓  (직접 DevTools Protocol 통신)
내장 Playwright Driver (node 기반)
   ↓
Chromium / Firefox / WebKit (Playwright 전용 빌드)
```

- Playwright로 코드 migration 진행

---
