## Story 01 HTTP 리퀘스트 메시지를 작성한다

##### 1. 탐험 여행은 URL 입력부터 시작한다

- 브라우저는 몇 개의 클라이언트 기능을 겸비한 복합적인 클라이언트 소프트웨어
- 따라서 여러 종류의 URL이 필요함
- 액세스 대상에 따라 형식이 다름
- URL의 제일 처음에는 액세스하는 방법을 적음
	- 웹 서버 액세스 -> http
	- 파일 다운/업로드 -> ftp
	- 메일 -> mailto

##### 2. 브라우저는 먼저 URL을 해독한다

- 웹 서버의 경우
	- `http:` + `//` + `웹 서버명` + `/` + `디렉토리명` + `/` + `...` + `/` + `파일명`

##### 3. 파일명을 생략한 경우

- 디렉토리에서 액세스할 파일명을 미리 서버측에 설정해 둠
	- 보통 'index.html' 또는 'default.htm'

- URL 끝에 `/`가 있는 경우:
	- 루트 디렉토리로 지정, 파일명 생략

- URL 끝에 `/`도 없는 경우
	- 디렉토리명도 생략한 경우
		- 루트 디렉토리의 'index.html' 또는 'default.htm' 파일에 액세스
	- `/`와 파일명을 생략한 경우, 파일명 뒤에 `/`를 생략한 경우
		- 해당하는 디렉토리가 있으면 디렉토리로, 해당하는 파일이 있으면 파일명으로 고려

##### 4. HTTP의 기본 개념

- 리퀘스트 메시지에는 "무엇을", "어떻게 해서"가 들어있음
- "무엇을" -> URI
	- 파일의 이름 or CGI 프로그램
- "어떻게 해서" -> 메소드

##### 5. 리퀘스트 메시지를 만든다

##### 6. 리퀘스트 메시지를 보내면 응답이 되돌아온다

## Story 02 웹 서버의 IP 주소를 DNS 서버에 조회한다

##### 01. IP 주소의 기본

- 브라우저는 HTTP 메시지를 만든 후 OS에 의뢰하여 액세스 대상의 웹 서버에게 송신함

- TCP/IP 네트워크는 작은 서브넷을 라우터로 연결하여 전체 네트워크를 완성
- 서브넷 안에 있는 한 대 혹은 여러 대의 허브가 서브넷 안의 모든 호스트를 연결함
- 허브는 서브넷 밖의 가장 가까운 라우터와 연결됨

- IP 주소는 네트워크 번호와 호스트 번호로 이루어져 있고 넷마스크로 이 둘의 경계를 나타냄

- 호스트 번호가 모두 0 -> 서브넷 자체
- 호스트 번호가 모두 1 -> 브로드캐스트

##### 02. 도메인명과 IP 주소를 구분하여 사용하는 이유

- IP 주소는 사람이 기억하기 어려우므로 도메인명을 사용함
- IP 주소는 4바이트이지만 도메인명은 훨씬 크기가 크므로 도메인명을 사용하면 라우터가 과부화됨
- DNS를 통해 도메인명과 IP 주소를 대응시킴

##### 03. Socket 라이브러리가 IP 주소를 찾는 기능을 제공한다

- 리졸버(DNS 리졸버)가 DNS 서버에 조회 메시지를 보냄
- name resolution: DNS의 원리를 사용하여 IP 주소를 조사하는 것

- Socket 라이브러리는 OS에 포함되어 있는 네트워크의 기능을 애플리케이션에서 호출하기 위한 부품을 모아놓은 것
- 리졸버는 Socket 라이브러리의 프로그램 부품들 중 하나

##### 04. 리졸버를 이용하여 DNS 서버를 조회한다

- 소켓 라이브러리의 gethostbyname() 호출
	- 인자값으로 조회하려는 서버의 도메인명을 제공

##### 05. 리졸버 내부의 작동

- 브라우저와 같은 네트워크 애플리케이션이 리졸버를 호출함
- 애플리케이션의 동작이 일시정지되고 리졸버에게 제어가 넘어감
- 리졸버를 바이너리 데이터로 메시지를 만든 후 DNS 서버에 문의하기 위해 OS 내부의 프로토콜 스택을 호출함
- 프로토콜 스택은 LAN 어댑터를 통해 메시지를 송신/수신함
- 리졸버는 프로토콜 스택으로부터 메시지를 수신한 후 애플리케이션에 값을 반환함

- DNS 서버의 IP 주소는 컴퓨터에 미리 설정되어 있고 직접 설정할 수 있음

## Story 03 전 세계의 DNS 서버가 연대한다

##### 01. DNS 서버의 기본 동작

- 리졸버가 보내는 조회 메시지에는 세 가지 정보가 포함되어 있음
	- 이름, 클래스 타입
- 이름:
	- 서버나 메일 배송 목적지와 같은 이름 (ex. 메일 주소에서 @ 뒷부분)
- 클래스:
	- 인터넷 이외의 네트워크에서의 이용까지 고려하였으나 인터넷 이외의 네트워크는 소멸되었으므로 클래스 값은 항상 인터넷을 나타내는 값인 'IN'
- 타입:
	- 조회하려는 레코드의 종류를 지정
	- 타입에 따라 클라이언트에 회답하는 정보의 내용이 달라짐
		- A 레코드 (Type = A): 도메인 이름 → IPv4 주소를 요청할 때.

- DNS 서버의 설정 파일에 등록 정보가 입력되어 있음
- 리소스 레코드

##### 02. 도메인의 계층

##### 03. 담당 DNS 서버를 찾아 IP 주소를 가져온다

- 루트 도메인의 DNS 서버에 관한 정보는 DNS 서버 소프트웨어와 함께 설정 파일로 배포되어 있으므로 DNS 서버 소프트웨어를 설치하면 자동으로 등록이 완료됨

##### 04. DNS 서버는 캐시 기능으로 빠르게 회답할 수 있다

- DNS 서버는 한 번 조사한 이름을 캐시에 기록하여 빠르게 회답할 수 있음

## Story 04 프로토콜 스택에 메시지 송신을 의뢰한다

##### 01. 데이터 송수신 동작의 개요

- OS 내부의 프로토콜 스택에 메시지 송신 동작을 의뢰
- Socket 라이브러리 프로그램 부품을 결정된 순번대로 호출
- 데이터 송수신용 프로그램 부품은 애플리케이션에서 의뢰받은 내용을 프로토콜 스택에 전달

- 프로토콜 스택이 데이터 송수신을 위해 하는 것
	- 서버 측에서 소켓을 만들고, 클라이언트가 소켓에 파이프를 연결하기를 기다림
	- 클라이언트도 소켓을 만들고, 자신의 소켓과 서버 측의 소켓을 파이프로 연결함
	- 데이터를 주고받음
	- 어느 한쪽에서 파이프를 분리하면 소켓이 말소됨

##### 02. 소켓의 작성 단계

- 브라우저가 Socket 라이브러리의 프로그램 부품을 결정된 순번대로 호출

- 클라이언트 측에서 소켓 만들기
	- 소켓 라이브러리의 socket() 호출
	- socket 내부로 제어가 넘어가서 소켓을 만든 후 애플리케이션으로 제어가 돌아옴
- 소켓이 생기면 애플리케이션에게 '디스크립터'라는 것이 돌아옴
	- 하나의 컴퓨터 내부에서 복수의 데이터 송수신이 이루어질 때, 각각의 소켓을 식별하기 위한 것
	- 디크스립터를 통해 프로토콜 스택은 어느 소켓을 사용하여 접속할지 또는 데이터를 송수신할지 판단할 수 있음

##### 03. 파이프를 연결하는 접속 단계

- 애플리케이션이 소켓 라이브러리의 connect()를 호출해 클라이언트의 소켓을 서버 측의 소켓에 접속하도록 프로토콜 스택에 의뢰
	- 디스크립터, 서버의 IP 주소, 포트 번호 이용
	- 디스크립터 -> 소켓 지정
	- 서버의 IP 주소 -> 데이터 송수신 시 이용
	- 포트 번호 -> 서버 측의 소켓 지정

##### 04. 메시지를 주고받는 송수신 단계

- 애플리케이션이 소켓 라이브러리의 write()를 호출해 프로토콜 스택에게 데이터를 송신하도록 의뢰

- 애플리케이션이 소켓 라이브러리의 read()를 호출해 프로토콜 스택에게 데이터를 수신하도록 의뢰
- 수신한 응답 메시지를 저장하기 위해 메모리 영역(수신 버퍼)을 지정
- 응답 메시지를 read()가 받아서 수신 버퍼에 저장

##### 05. 연결 끊기 단계에서 송수신이 종료된다

- 애플리케이션이 소켓 라이브러리의 close()를 호출해 프로토콜 스택에게 연결 끊기 단계로 들어가도록 의뢰
- 파이프 분리, 소켓 말소
