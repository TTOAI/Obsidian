
참고: - [Google Codelabs - A2A 프로토콜 시작하기](https://codelabs.developers.google.com/intro-a2a-purchasing-concierge?hl=ko#1)

---

# 1. 소개

- A2A 프로토콜: 외부 시스템에 배포된 AI 에이전트 간의 통신을 표준화하도록 설계된 프로토콜.
- MCP(Model Context Protocol): 데이터 및 리소스와 LLM을 연결하는 프로토콜.

- A2A와 MCP의 차이점:
	- MCP:
		- 에이전트를 도구 및 데이터에 연결하는 복잡성을 낮추는 데 중점을 둠.
	- A2A:
		- 에이전트가 자연스러운 방식으로 공동작업할 수 있도록 하는 방법에 중점을 둠.
		- 에이전트가 도구가 아닌 에이전트로 소통할 수 있음.
		- [공식문서](https://a2a-protocol.org/latest/)에서는 애플리케이션이 도구에는 MCP를 사용하고 에이전트에는 A2A를 사용할 것을 권장함.

![[Pasted image 20260110123605.png]]

- A2A는 클라이언트-서버 원칙을 활용함
- 이 튜토리얼에서 예상되는 일반적인 A2A 흐름은 아래와 같음
	![[Pasted image 20260110123811.png]]
	1. `A2A 클라이언트`는 먼저 액세스 가능한 모든 `A2A 서버` `에이전트 카드`에서 검색을 실행하고 해당 정보를 활용하여 연결 클라이언트를 빌드함.
	2. 필요한 경우 A2A 클라이언트는 A2A 서버에 메시지를 전송하고 서버는 이를 완료해야 하는 작업으로 인식함.
	3. A2A 서버가 요청을 처리함. 푸시 알림 수신자 URL이 A2A 클라이언트에 구성되어 있고 A2A 서버에서 지원되는 경우 서버는 클라이언트의 수신 엔드포인트에 작업 진행 상태를 게시할 수도 있음.
	4. 작업이 완료되면 A2A 서버가 응답 아티팩트를 A2A 클라이언트에 전송함.

## 아키텍처 개요

![[Pasted image 20260110130256.png]]
- A2A 서버 역할을 하는 두 가지 서비스(CrewAI 에이전트 프레임워크로 지원되는 Burget 에이전트, LangGraph 에이전트 프레임워크로 지원되는 Pizza 에이전트)를 배포함.
- 사용자는 A2A 클라이언트 역할을 하는 에이전트 개발 키트(ADK) 프레임워크를 사용하여 실행되는 구매 컨시어지와만 직접 상호작용함.
- 각 에이전트는 자체 환경과 배포를 가짐.

# 2. 워크숍 개발 설정 준비

- Google Console에서 프로젝트 생성.

- 무료 체험판 결제 계정 연결.

- Cloud Shell 연결.
	1. 셸이 계정으로 이미 인증되었는지 확인.
		```
		gcloud auth list
		```
	2. 다음과 같이 뜨면 정상.
		```
		Credentialed Accounts
		
		ACTIVE: *
		ACCOUNT: 2ju1230@gmail.com
		
		To set the active account, run:
		    $ gcloud config set account `ACCOUNT`
		```

- Cloud Shell에서 아래 레포지토리에 대해 git clone 수행.
	```
	git clone https://github.com/alphinside/purchasing-concierge-intro-a2a-codelab-starter.git purchasing-concierge-a2a
	```

- Cloud Shell에서 편집기(Editor) 열기.

- **purchasing-concierge-a2a** 디렉터리를 기본 작업 디렉토리로 설정.

- 다음 명령어를 실행하여 **.venv** 디렉터리의 가상 환경에 필요한 종속 항목을 설치
	```
	uv sync --frozen
	```

- 아래의 명령어를 통해 필요한 API를 사용 설정.
```
gcloud services enable aiplatform.googleapis.com \
                       run.googleapis.com \
                       cloudbuild.googleapis.com \
                       cloudresourcemanager.googleapis.com
```

- 명령어가 성공적으로 실행되면 아래와 유사한 메시지가 표시됨.
```
Operation "operations/..." finished successfully.
```

# 3. 버거 판매자 에이전트 - A2A 서버 배포

![[Pasted image 20260110140105.png]]
- 빨간색 상자로 표시된 두 개의 원격 판매자 에이전트 중 햄버거 에이전트 배포.
- 햄버거 에이전트는 CrewAI 에이전트 프레임워크로 구동됨.

- 다음 명령어를 실행하여 배포.
	```
	gcloud run deploy burger-agent \
	    --source remote_seller_agents/burger_agent \
	    --port=8080 \
	    --allow-unauthenticated \
	    --min 1 \
	    --region us-central1 \
	    --update-env-vars GOOGLE_CLOUD_LOCATION=us-central1 \
	    --update-env-vars GOOGLE_CLOUD_PROJECT=a2a-agent-engine-483904
	```

- 새 브라우저 탭을 열고 브라우저를 통해 배포된 버거 에이전트 서비스의 `https://burger-agent-732259039336.us-central1.run.app/.well-known/agent.json` 경로로 이동.
	- 배포된 A2A 서버 에이전트 카드에 액세스하는 URL.
- 아래와 같은 응답이 표시됨.
	![[Pasted image 20260110141141.png]]
- `url` 값이 여전히 `http://0.0.0.0:8080/`로 설정되어 있음.
- 이 `url` 값은 A2A 클라이언트가 외부에서 메시지를 전송하는 데 필요한 기본 정보임.
- 환경변수 `HOST_OVERRIDE`를 추가하여 이 값을 버거 에이전트 서비스의 URL로 업데이트해야 함.

- Cloud 콘솔 상단의 검색창에서 Cloud Run을 검색함.
- 이전에 배포된 burger-agent Cloud Run 서비스를 클릭.
- 버거 서비스 URL을 복사한 다음 새 버전 수정 및 배포를 클릭.
- 변수 및 보안 비밀 섹션을 클릭.
- 변수 추가를 클릭하고 `HOST_OVERRIDE` 값을 서비스 URL(`https://burger-agent-732259039336.us-central1.run.app`)로 설정.
	![[Pasted image 20260110142115.png]]
- - 새 브라우저 탭을 열고 `https://burger-agent-732259039336.us-central1.run.app/.well-known/agent.json` 경로로 이동하여 url 값 확인.
	![[Pasted image 20260110142227.png]]

# 4. 피자 판매자 에이전트 배포 - A2A 서버

- 아래의 명령어를 수행하여 배포.
	```
	gcloud run deploy pizza-agent \
		--source remote_seller_agents/pizza_agent \
		--port=8080 \
		--allow-unauthenticated \
		--min 1 \
		--region us-central1 \
		--update-env-vars GOOGLE_CLOUD_LOCATION=us-central1 \
		--update-env-vars GOOGLE_CLOUD_PROJECT=a2a-agent-engine-483904
	```

- 버거 에이전트와 동일하게 url 값 수정.

# 5. 구매 컨시어지 - A2A 클라이언트를 Agent Engine에 배포

- 아래의 명령어로 Cloud Storage에 스테이징 스토리지를 만듦.
	```
	gcloud storage buckets create gs://purchasing-concierge-a2a-agent-engine-483904 --location=us-central1
	```

- `.env.example` 파일 복사 후 알맞은 값으로 수정.
```
cp .env.example .env
```

- 에이전트 엔진 배포.
```
uv run deploy_to_agent_engine.py
```

- 콘솔에서 `Agent Engine` 리소스 이름 확인 후 `.env` 파일의 `AGENT_ENGINE_RESOURCE_NAME` 업데이트.

- 아래의 명령어를 통해 에이전트가 성공적으로 배포되었는지 테스트.
	```
	bash test_agent_engine.sh
	```

# 6. 통합 테스트 및 페이로드 검사

- 웹 UI를 사용하여 원격 에이전트 상호작용으로 구매 컨시어지를 검사해보기.

- 아래의 명령어를 통해 Gradio 앱 배포.
	```
	uv run purchasing_concierge_ui.py
	```

# 7. A2A 서버 개념 및 구현

- 두 판매자 에이전트는 클라이언트 에이전트와 완전히 다른 프레임워크로 빌드됨.
- A2A를 사용하면 문제가 되지 않음.
	- 서로 통신하기 위해 내부 코드를 공유할 필요가 없으며, 사용되는 프레임워크, 활용되는 언어, 배포 위치가 중요하지 않음.

## A2A 서버의 핵심 구성요소

### 에이전트 카드

- 각 A2A 서버에는 `/.well-known/agent.json` 리소스에서 액세스할 수 있는 에이전트 카드를 가짐.
- A2A 클라이언트의 검색 단계를 지원하기 위해 존재함.
- 에이전트에 액세스 하는 방법, 모든 기능을 파악하는 방법에 관한 완전한 정보와 컨텍스트를 제공함.
- Swagger 또는 Postman을 사용하여 문서화가 잘 된 API 문서와 비슷함.
- `burger agent` 에이전트 카드의 콘텐츠는 다음과 같음.
	![[Pasted image 20260110141141.png]]
- 이러한 에이전트 카드에는 에이전트 기술, 스트리밍 기능, 지원되는 모달리티, 프로토콜 버전 등 다양한 중요 구성요소가 표시됨.
- 이 모든 정보를 활용하여 A2A 클라이언트가 올바르게 통신할 수 있도록 적절한 통신 메커니즘을 개발함.
- 코드에서의 에이전트 카드 구현은 A2A Python SDK를 사용하여 다음과 같이 설정됨.
	![[Pasted image 20260112015711.png]]

### 테스트 큐 및 에이전트 실행기

- 각 A2A 서버는 수신 작업을 추적하고 이에 관한 적절한 정보를 저장할 수 있어야 함.
- A2A SDK에서 제공하는 모듈을 통해 수신 요청을 처리하는 방법을 나타내는 로직을 인스턴스화할 수 있음.
- 아래의 코드는 AgentExecutor 추상 클래스를 상속하여 작업 실행 및 취소를 관리하는 방법을 제어하는 코드임.
	- `remote_seller_agents/burger_agent/agent_executor.py`
	![[Pasted image 20260112023219.png]]
- 아래의 코드는 BurgerSellerAgentExecutor와 함께 DefaultRequestHandler, InMemoryTaskStore, 및 A2AStarletteApplication을 활용하여 HTTP 서버를 시작하는 코드임.
	- `remote_seller_agents/burger_agent/__main__.py`
	![[Pasted image 20260112023553.png]]
	- 이 모듈은 에이전트 카드에 액세스하는 `/.well-known/agent.json` 경로와 A2A 프로토콜을 지원하는 POST 엔드포인트를 구현함.

### A2A 서버의 두 가지 핵심 기능 요약
- 두 기능 모두 Python SDK를 사용하여 구현하고 배포함.
1. `/.well-known/agent.json` 경로에 상담사 카드 게시
2. 메모리 내 작업 대기열을 사용하여 JSON-RPC 요청 처리

# Agent Engine 배포

- 구매 컨시어지 에이전트는 ADK를 사용하여 빌드되고 Agent Engine에 배포됨.
- Vertex AI Agent Engine
	- 개발자가 프로덕션에서 AI 에이전트를 배포, 관리, 확장할 수 있도록 지원하는 서비스 모음임.
	- 프로덕션에서 에이전트를 확장하는 데 필요한 인프라를 처리하므로 애플리케이션을 만드는 데 집중할 수 있음.
		- ADK와 Agent Engine을 함께 사용하여 자체 백엔드 서비스를 개발하지 않고도 Python 스크립트에서 직접 에이전트를 배포할 수 있음.

# A2A 클라이언트 개념 및 구현

![[Pasted image 20260112030243.png]]

- 위의 이미지에서 나오는 A2A 상호작용 흐름
	1. 클라이언트는 `/.well-known/agent.json` 경로의 제공된 원격 에이전트 URL에서 게시된 에이전트 카드를 찾으려고 시도함.
	2. 그런 다음 필요한 경우 메시지와 필요한 메타데이터 매개변수 ( 예: 세션 ID, 이전 컨텍스트 등)를 사용하여 해당 에이전트에게 메시지를 전송함. 서버는 이 메시지를 완료해야 하는 작업으로 인식함.
	3. 2A 서버는 요청을 처리함. 서버가 푸시 알림을 지원하는 경우 작업 처리 전반에 걸쳐 알림을 게시할 수도 있음.
	4. 완료되면 A2A 서버가 응답 아티팩트를 클라이언트에 다시 전송함.
- 메시지: 클라이언트와 서버 간의 커뮤니케이션 턴
- 작업: A2A에서 관리하는 기본 작업 단위로, 고유 ID로 식별됨.
- 아티팩트: 작업의 결과로 에이전트가 생성한 출력 (예: 문서, 이미지, 구조화된 데이터)으로, 파트로 구성됨.
- Part: 메시지 또는 아티팩트 내의 가장 작은 콘텐츠 단위임. 부분은 텍스트, 이미지, 동영상, 파일 등이 될 수 있음.

## 카드 검색

- A2A 클라이언트에서 `A2ACardResolver`를 이용해 사용 가능한 모든 에이전트 카드에 액세스하려고 시도한 후 다음 에이전트에 메시지를 보내는 데 필요한 연결을 수집함.
- 에이전트가 사용 가능한 모든 에이전트와 사양을 프롬프트에 나열하여 해당 에이전트와 통신할 수 있음을 알림.

## 프롬프트 및 작업 전송 도구

- Google에서 ADK 에이전트에 적절한 프롬프트와 도구를 구현함.
- 프롬프트에서는 구매 컨시어지 에이전트에게 사용 가능한 모든 원격 에이전트 이름과 설명을 제공함.
- 도구(`self.send_task`)에서는 에이전트에 연결할 적절한 클라이언트를 가져오고 `SendMessageRequest` 객체를 사용하여 필요한 메타데이터를 전송하는 메커니즘을 제공함.

## 통신 프로토콜

![[Pasted image 20260112032243.png]]
![[Pasted image 20260112032228.png]]
- A2A 클라이언트는 서버로 메시지를 전송함.
- A2A 서버는 수신되는 메시지를 작업으로 정의함. 수신되는 메시지를 어떤 작업으로 정의할지, 작업을 완료하는 데 클라이언트의 상호작용이 필요한지는 서버가 정함.
- A2A 서버는 다양한 유형의 통신 (예: 동기화, 스트리밍, 비동기)을 지원하거나 작업 상태에 대한 알림을 구성하는 등 유연하게 구성할 수 있음.
