
## 기본적인 프로세스
- 만료된 ATK와 함께 클라이언트에서 요청을 보냄
- 서버에서 RTK를 요청하는 응답을 보냄
- 클라이언트에서 만료된 ATK와 RTK를 함께 보냄
- 서버에서 ATK가 만료된 것과 RTK가 유효한 것을 확인 후 ATK를 새로 발급해줌
- 이 때, RTK 또한 새로 발급해주는 것이 RTR(Refresh Token Rotation)임

## 만약 ATK가 탈취 당했다면
- ATK가 만료되기 전까지는 무방비 상태임

## 만약 RTK이 탈취 당했다면
- RTK를 통해 ATK를 새로 발급 받을 가능성이 있음
- RTK를 통해 ATK를 새로 발급 받기 위해서는 무조건 만료된 ATK와 RTK를 함께 서버에 보내도록 함
- 추가적으로 만료되지 않은 ATK와 RTK를 함께 서버에 보냈을 때 ATK와 RTK를 모두 무효화함
- RTK은 서버에서 지우고, ATK은 만료 시간을 0으로 설정

## 만약 ATK, RTK를 함께 탈취 당했다면
- ATK가 만료되고 아이디 주인이 RTK를 통해 ATK, RTK를 새로 발급 받기 전까지 무방비 상태임
- ATK가 만료되고 탈취한 자가 RTK를 통해 ATK, RTK를 새로 발급 받았다면, 아이디 주인이 RTK를 통해 ATK, RTK를 요청했을 때 아이디 주인이 가진 RTK가 유효하지 않은 것이 확인됨
- RTK이 유효하지 않은 것이 확인되면 서버가 보관하고 있는 RTK도 지워서 모든 RTK를 무효화하고  로그인 페이지로 리디렉션함

## 비슷한 시간에 서로 다른 장소에서 로그인을 했을 때
- 먼저 로그인한 곳에서 발급 받은 RTK이 서버에 저장되어 있는 상태에서 나중에 로그인한 곳에서 RTK를 발급 시도함
- 서버에 저장된 RTK이 나중에 로그인한 곳의 RTK으로 대체됨
- 먼저 로그인한 곳에서는 ATK가 만료되었을 때 RTK이 유효하지 않으므로 재 로그인해야 함

## 결론
- RTK만 탈취 당한 경우, RTK만으로 할 수 있는 것은 없으므로 괜찮음
- ATK를 탈취 당한 경우, ATK가 만료되기 전까지는 무방비 상태임
- ATK와 RTK를 모두 탈취 당한 경우, ATK가 만료된 후 아이디 주인이 RTK를 통해 ATK, RTK를 요청하기 전까지 무방비 상태임
  -> 브라우저의 쿠키에 저장된 ATK, RTK은 탈취하기 쉬운 거 아닌가??????
---
## 요청으로 올 수 있는 토큰 조합
- 만료되지 않은 ATK -> 무방비

- 만료된 ATK -> RTK 요청

- 만료된 ATK + 유효한 RTK -> ATK, RTK 모두 새로 발급

- 만료된 ATK + 유효하지 않은 RTK -> RTK 삭제 및 401 반환

- 만료되지 않은 ATK + 유효한 RTK -> RTK 삭제 및 401 반환
- 만료되지 않은 ATK + 유효하지 않은 RTK -> RTK 삭제 및 401 반환

- 유효한 RTK -> RTK 삭제 및 401 반환
- 유효하지 않은 RTK -> RTK 삭제 및 401 반환
---
## 최종 개발 고려 사항
- ATK만 왔을 때 -> 만료 유무 확인 후 알맞은 코드 수행
- ATK, RTK 같이 왔을 때
	- ATK 만료됨 -> RTK 유효한지 확인 후 알맞은 코드 수행
	- ATK 만료되지 않음 -> RTK 삭제 및 401 반환
- RTK만 왔을 때 -> RTK 삭제 및 401 반환

---
## 1. 일반 API 요청

### 1-1. Access token만 전달된 경우

- **유효한 경우:**
    
    - **처리:** 요청을 정상 처리
    - **응답 코드:** 200 OK
- **만료되었거나 유효하지 않은 경우:**
    
    - **처리:** access token 검증 실패
    - **응답 코드:** 401 Unauthorized
    - **에러 메시지:**
        - `"유효하지 않거나 만료된 access token입니다. 토큰을 갱신해주세요."`

### 1-2. Access token과 함께 Refresh token이 함께 전달된 경우

- **옵션 A (refresh token 무시, 로깅 포함):**
    
    - **access token이 유효한 경우:**
        - **처리:** access token만 검증하고 refresh token은 무시 (단, 내부 로깅)
        - **응답 코드:** 200 OK
    - **access token이 만료되거나 유효하지 않은 경우:**
        - **처리:** access token 검증 실패
        - **응답 코드:** 401 Unauthorized
        - **에러 메시지:**
            - `"유효하지 않거나 만료된 access token입니다. 토큰을 갱신해주세요."`
- **옵션 B (보안 위협으로 판단하여 두 토큰 모두 무효화):**
    
    - **어떠한 경우에도:**
        - **처리:** refresh token이 일반 API 요청에 포함된 것을 보안 이상으로 간주
        - **응답 코드:** 401 Unauthorized
        - **에러 메시지:**
            - `"부적절한 토큰 조합이 감지되었습니다. 재로그인이 필요합니다."`

### 1-3. **Refresh token만 전달된 경우 (일반 API 요청)**

- **처리:**
    - 일반 API 요청에서는 access token이 반드시 있어야 하므로, refresh token만 있는 경우는 잘못된 요청으로 판단합니다.
- **응답 코드:** 401 Unauthorized
- **에러 메시지:**
    - `"인증에 필요한 access token이 누락되었습니다. 올바른 인증 정보를 제공해주세요."`

---

## 2. 토큰 갱신 요청 (예: `/auth/refresh` 엔드포인트)

토큰 갱신 요청에서는 주로 HttpOnly 쿠키로 전달되는 refresh token을 기반으로 새로운 토큰을 발급합니다. 아래는 시나리오별 처리 방식입니다.

### 2-1. Refresh token만 전달된 경우

- **유효한 경우:**
    - **처리:** refresh token 검증 후 새로운 access token(및 필요 시 refresh token) 발급
    - **응답 코드:** 200 OK
- **유효하지 않은 경우:**
    - **처리:** refresh token 검증 실패
    - **응답 코드:** 401 Unauthorized (또는 보안 정책에 따라 403 Forbidden도 고려 가능)
    - **에러 메시지:**
        - `"유효하지 않은 refresh token입니다. 다시 로그인해주세요."`

### 2-2. 만료된 access token과 함께 refresh token이 전달된 경우

- **access token이 만료되었고 refresh token이 유효한 경우:**
    - **처리:** refresh token을 통해 새로운 토큰 발급
    - **응답 코드:** 200 OK
- **access token이 아직 유효한 경우 (예상치 못한 상황):**
    - **처리:** 보안상의 문제로 간주
        - 두 토큰 모두를 무효화하고 강제 재로그인을 유도
    - **응답 코드:** 401 Unauthorized
    - **에러 메시지:**
        - `"유효한 access token과 함께 refresh token이 전달되었습니다. 보안상의 이유로 재인증이 필요합니다."`

### 2-3. Access token만 전달된 경우

- **처리:**
    - 토큰 갱신 요청에는 반드시 refresh token이 포함되어야 합니다.
- **응답 코드:** 401 Unauthorized
- **에러 메시지:**
    - `"토큰 갱신 요청에 refresh token이 누락되었습니다."`

### 2-4. 두 토큰 모두 전달되지 않은 경우

- **처리:**
    - 인증 정보가 전혀 없으므로 요청 거부
- **응답 코드:** 401 Unauthorized
- **에러 메시지:**
    - `"인증 정보가 제공되지 않았습니다. 로그인이 필요합니다."`
