
### 파이썬 데코레이터

- 함수를 입력으로 받아 추가 기능을 더한 후 함수를 반환함
- 기존 코드를 수정하지 않으면서 함수나 클래스의 기능을 확장하거나 수정할 수 있게 해주는 `호출 가능한 객체`
	- `호출 가능한 객체`: 함수, 클래스, __call__ 메서드를 구현한 클래스의 인스턴스
	- `호출 불가능한 객체`: 숫자, 문자열, 리스트, 튜플, 딕셔너리
- 예시:
	- `@simple_decorator`는 `greet = simple_decorator(greet)`와 기능상 동일
```python
# 1. 데코레이터 정의
def simple_decorator(func):
    def wrapper():
        print(">>> 함수가 호출되기 전입니다.") # 추가 기능 (전)
        func() # 원래 함수 호출
        print("<<< 함수 호출이 끝났습니다.") # 추가 기능 (후)
    return wrapper

# 2. 데코레이터 적용
@simple_decorator
def greet():
    print("안녕하세요!") 
```


### 파이썬의 **함수**는 일급 객체

- `일급 객체(일급 함수)`: 프로그래밍 언어에서 다른 일반적인 데이터 타입과 동일하게 취급되는 엔티티(변수, 함수)
- 다음의 조건들을 만족해야 함
	- 변수에 할당 가능
	- 다른 함수의 인수로 전달 가능
	- 다른 함수의 반환 값으로 사용 가능
	- 자료 구조에 저장 가능
- 파이썬에서 `데코레이터`와 같은 프로그래밍이 가능한 이유


### 파이썬 객체의 메타데이터 속성

- __name__: 함수 또는 클래스의 이름
- __module__: 해당 함수가 정의된 모듈 이름
- __qualname__: 함수의 전체 이름 (중첩된 경우)
- 예시:
```python
# 파일 구조
models/
 ├── __init__.py
 ├── bert.py

# bert.py
 def bert(...):
    ...

bert.__name__     → 'bert'
bert.__module__   → 'models.bert'
```


### 파이썬 라이브러리 Transformers

- 주로 구글의 Transformer 아키텍처를 기반으로 한 사전 학습된(Pre-trained) 모델들을 불러오고, 사용하고, 미세 조정(Fine-tuning)할 수 있는 통합된 인터페이스를 제공
- `pipeline()` 함수를 통해 복잡한 전처리(토크나이징), 모델 추론, 후처리 과정을 쉽게 처리 가능
- 딥러닝 프레임워크 PyTorch, TensorFlow를 모두 지원
- 토크나이저(Tokenizer)를 각 모델에 맞게 자동 제공
- 핵심 Auto 클래스: AutoModel, AutoConfig
- 예시:
```python
from transformers import AutoModel, AutoConfig

# 1. 설정 로드
config = AutoConfig.from_pretrained("bert-base-uncased")

# 2. 가중치 없이 모델 초기화
model = AutoModel.from_config(config) # 이 모델은 무작위로 초기화된 가중치를 가짐
```


### 파이썬의 명령줄 인자 파싱

- ArgumentParser
	- 명령줄 옵션을 정의하고 파싱 규칙을 지정하는 클래스
	- parse_args(): Namespace 객체를 반환함
- Namespace
	- 실제 명령줄 옵션 입력값을 저장하는 데이터 객체
- 예시:
```python
import argparse

parser = argparse.ArgumentParser(description="테스트 프로그램")
parser.add_argument("--name", required=True, help="사용자 이름")
parser.add_argument("--age", type=int, default=20)

args = parser.parse_args()

```


### 리스트를 더하면

- `단일리스트` + `단일리스트` -> `단일리스트`
```python
list1 = [['1', '2', '3'], ['4', '5', '6'], ['7', '8', '9']]
sum_list = list1[0] + list1[1] + list1[2]
print(sum_list)

# Output: ['1', '2', '3', '4', '5', '6', '7', '8', '9']
```

- sum(`중첩리스트`, []) -> `단일리스트`
	- sum() 계산의 매 단계마다 새로운 리스트가 생성
	- 메모리 할당 및 복사 작업이 반복되기 때문에 매우 비효율적
	- 권장되는 방법: `리스트 컴프리헨션`
```python
list1 = [['1', '2', '3'], ['4', '5', '6'], ['7', '8', '9']]
sum_list = sum(list1, [])
print(sum_list)

# Output: ['1', '2', '3', '4', '5', '6', '7', '8', '9']
```

- `리스트 컴프리헨션`
```python
sum_list = [item for sublist in list1 for item in sublist]
```
