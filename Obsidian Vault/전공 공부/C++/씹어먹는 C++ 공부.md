- 왜 iostream 헤더파일을 선언한 후 다른 헤더파일이나 namespace와 달리 std를 호출할 때 iostream::std와 같이 쓰지 않는가?
	iostream 안에 std 라는 namespace가 하나밖에 없어서?

- 레퍼런스
	- 포인터는 변수의 주소값을 받아 해당 변수를 가리킨다. 레퍼런스는 자체의 주소값이 없고 변수의 주소값을 사용하며 해당 변수와 동일하게 취급받는다.
	- 레퍼런스는 반드시 처음에 누구의 별명이 될 것인지 지정해야 한다.
	- 레퍼런스가 한 번 별명이 되면 절대로 다른 이의 별명이 될 수 없다.
	- 포인터와 레퍼런스 모두 리턴할 때 변수의 주소값만 복사하면 된다는 점에서 유용하다. ex) 엄청나게 큰 구조체가 있는 경우 구조체를 가리키는 포인터를 리턴하면 포인터 주소 한 번 복사로 빠르게 끝남, 레퍼런스도 마찬가지
	- (예외사항) 상수 레퍼런스로 리턴값을 받게 되면(상수 레퍼런스를 리턴값으로 초기화하면) 리턴값은 해당 상수 레퍼런스가 사라질 때까지 유효하다. ex) const int& c = function();

- ..
- 스택(stack): 프로그램을 정확하게 실행하기 위해 컴파일 시에 모든 변수의 주소값이 확정된다.
- 힙(heap): 프로그램 실행 시에 메모리를 자유롭게 할당하고 해제할 수 있다.
- 객체(object): 변수들과 참고 자료들로 이루어진 소프트웨어 덩어리
- 인스턴스 변수: 객체에 정의되어 있는 변수, 객체에 대한 정보를 담고 있다.
- 인스턴스 메소드: 객체에 정의되어 있는 함수, 객체의 인스턴스 변수를 초기화하거나 인스턴스 변수를 이용해서 객체 외의 것들에 영향을 줄 때 이용한다.
- 캡슐화(encapsulation): 인스턴스 메소드를 통해서 변수를 간접적으로 조절하는 것(직접 접근 불가)
- 클래스(class): 객체를 만들 수 있는 설계도, 이를 이용해 만들어진 객체를 인스턴스(instance)
- 멤버 변수, 멤버 함수: 클래스 상에 있는 변수와 함수.
- 접근 지시자 public, pravite: 클래스 외부에서 직접 접근 가능 여부, 명시하지 않으면 private.(struct와의 차이점)
- C++에서는 함수의 오버로딩이 가능해서 함수의 인자가 다르면 이름은 같아도 된다.
- 함수의 오버로딩 규칙을 대강은 외워놓자.
- 생성자(constructor): 객체 생성시 자동으로 호출되는 함수, 클래스이름(인자) {내용}
- 디폴트 생성자(default constructor): 인자를 하나도 가지지 않는 생성자, 클래스이름() {내용}, 객체 만들 때 주의.
- new가 malloc과 다른 점: 객체를 동적으로 생성하면서 생성자도 호출해준다.
- 소멸자(desctructor): 객체가 소멸될 때 자동으로 호출되는 함수. 객체 안에서 동적 할당했던 메모리를 해제하여 메모리 누수를 방지해준다.
- 복사 생성자(copy constructor): 어떤 클래스 T에 대하여 T(const T& a); 로 정의됨.
- 디폴드 복사 생성자의 경우에는 깊은 복사(deep copy, 메모리를 새로 할당해서 내용을 복사하는 것)를 못 함.
- 초기화 리스트(initializer list): 생성자와 달리 생성과 초기화를 동시에 함. 상수와 레퍼런스들은 모두 생성과 동시에 초기화가 되어야 함.
	- 디폴트 생성자와 뭐가 다른지 모르겠음.(상수와 레퍼런스를 멤버 변수로 둔 클래스 제외)
- static 멤버 변수, static 함수: static 멤버 변수, 함수는 하나의 객체에 종속되지 않음. 따라서 static 함수에서는 클래스의 static 멤버 변수밖에 못 씀.
	- 다른 멤버 변수들은 private이라서 객체 외부에서 접근 못한다고 했는데, static 멤버 변수는 어떻게 클래스::static 멤버 변수 = ? 식으로 초기화 가능한가?
- 객체 자기 자신을 리턴하고 싶을 땐 리턴 타입을 클래스이름& 으로 하고 *this를 반환하기.
- 상수 멤버 함수: (기존 함수의 정의) const {};, 다른 변수의 값을 바꾸지 않는 함수. 상수 함수 내에서는 다른 상수 함수밖에 호출할 수 없음.
- class의 장점: 소멸자가 있기 때문에 동적 할당을 하더라도 소멸자에서 이를 자동으로 처리하게 할 수 있다.
- 내부 멤버 변수의 값을 바꾸지 않는다면 상수 함수로 정의하는 것이 좋음. (4-4)
