## Story 01 소켓을 작성한다

##### 1. 프로토콜 스택의 내부 구성

- 프로토콜 스택: OS에 내장된 네트워크 제어용 소프트웨어
- LAN 어댑터: OS에 내장된 네트워크용 하드웨어
- 프로토콜 스택과 LAN 어댑터가 브라우저에서 받은 메시지를 서버에 송출
- 애플리케이션
    - 네트워크 애플리케이션: 웹 브라우저, 메일러, 웹 서버, 메일 서버 등
    - Socket 라이브러리: 리졸버 내장
- OS
    - 프로토콜 스택 존재
    - TCP: 일반적인 애플리케이션의 데이터 송수신
    - UDP: 짧은 제어용 데이터 송수신 (ex. DNS 서버)
    - IP: 패킷 송수신
        - ICMP: 패킷 운반 시 발생하는 오류 및 제어용 메시지 통지
        - ARP: IP 주소에 대응하는 이더넷의 MAC 주소 조사
- 드라이버 소프트웨어
    - LAN 드라이버: LAN 어댑터 제어
- 하드웨어
    - LAN 어댑터

##### 2. 소켓의 실체는 통신 제어용 제어 정보

- 프로토콜 스택의 메모리 영역에 제어 정보 기록
    - 통신 상대의 IP 주소, 포트 번호, 통신 동작의 진행 상태 등등
- 개념적으로 소캣이 제어 정보를 가지고 있다고 생각해도 됨
- 프로토콜 스택은 소켓에 기록된 제어 정보를 참조하면서 움직임

##### 3. Socket을 호출했을 때의 동작

- Socket 라이브러리: Application Layer와 Transport Layer 사이에 존재하는 인터페이스 역할
- OS: 통신 기능 구현 및 실행 (소프트웨어)
- OSI 7계층: 통신 과정의 개념적 모델 (이론)
- 시스템 콜:
    - OS 커털의 기능(하드웨어 제어 등)을 요청
    - 커널 모드에서 실행됨
1. 애플리케이션이 socket을 호출하여 소켓을 만들 것을 의뢰
2. 프로토콜 스택이 한 개의 소켓을 만듦
    1. 소켓 한 개 분량의 메모리 영역 확보
    2. 소켓을 나타내는 디스크립터를 애플리케이션에 알려줌

## Story 02 서버에 접속한다

##### 01 접속의 의미

- 통신 상대와의 사이에 제어 정보를 주고받아 소켓에 필요한 정보를 기록하고 데이터 송수신이 가능한 상태로 만드는 것
- 버퍼 메모리의 확보
    - 버퍼 메모리: 데이터 송수신 동작을 실행할 때 송수신하는 데이터를 일시적으로 저장하기 위한 메모리 영역

##### 02 맨 앞 부분에 제어 정보를 기록한 헤더를 배치한다

- 제어 정보의 종류
    - 클라이언트와 서버가 서로 연락을 절충하기 위해 주고받는 정보
        - 헤더에 기입됨
    - 소켓(프로토콜 스택의 메모리 영역)에 기록하여 프로토콜 스택의 동작을 제어하기 위한 정보
        - 소켓에 기록한 제어 정보는 상대측에서 볼 수 없음

##### 03 접속 동작의 실제

1. connect 호출
2. TCP 담당 부분에서 접속을 나타내는 제어 정보를 기록한 TCP 헤더를 만듦
3. TCP 헤더의 송신처와 수신처의 포트 번호로 접속하는 소켓 지정
4. SYN 비트를 1로 만듦
    - SYN은 컨트롤 비트라고 불림
5. IP 담당 부분에 건네주어 송신하도록 의뢰
6. IP 담당 부분이 패킷 송신 동작을 실행
7. 네트워크를 통해서 패킷이 서버에 도착
8. 서버측의 TCP 담당 부분이 TCP 헤더를 조사하고 접속을 기다리는 소켓을 찾음
9. 소켓에 필요한 정보를 기록하고 접속 동작이 진행 중으로 바뀜
10. ACK 비트를 1로 만듦
11. 서버의 TCP 담당 부분은 응답을 돌려보냄
12. 클라이언트 측에서 TCP 헤더를 조사하여 접속 동작 성공 여부 파악
    - ==SYN이 1인지 확인??? → 118쪽==
    - 소켓에 접속 완료를 나타내는 제어 정보 기록
- 클라이언트 측에 패킷이 도착한 것을 서버에 알리기 위해 ACK 비트를 1로 만든 TCP 헤더를 반송

## Story 03 서버에 접속한다

##### 01 프로토콜 스택에 HTTP 리퀘스트 메시지를 넘긴다
- 애플리케이션에서 프로토콜 스택에 건네주는 데이터의 길이 판단 요소 1:
	- 한 패킷에 저장할 수 있는 데이터의 크기
	- MTU:
		- 한 패킷으로 운반할 수 이는 디지털 데이터의 최대 길이
		- 이더넷에서는 보통 1,500바이트
	- MSS:
		- 패킷에서 헤더를 제외한 것
		- 하나의 패킷으로 운반할 수 있는 TCP의 데이터의 최대 길이
- 애플리케이션에서 프로토콜 스택에 건네주는 데이터의 길이 판단 요소 2:
	- 프로토콜 스택 내부 타이머 -> 일정 시간 경과하면 패킷 송신하여 속도 지연 방지
##### 02 데이터가 클 때는 분할하여 보낸다
- 폼을 사용하여 긴 데이터를 보낼 경우 여러 패킷으로 분할
##### 03 ACK 번호를 사용하여 패킷이 도착했는지 확인한다
- 데이터의 조각을 송신할 때 세어둔 값을 TCP 헤더에 기록 -> 시퀀스 번호
- 수신측은 그 이전에 수신한 데이터와 합쳐서 데이터를 몇 번째 바이트까지 수시한 것인지 계산
- 그 값을 TCP 헤더의 ACK 번호에 기록하여 송신측에 알려줌
	- 수신 확인 응답
- 실제로 시퀀스 번호는 난수를 바탕으로 산출한 초기값으로 시작
##### 04 패킷 평균 왕복 시간으로 ACK 번호의 대기 시간을 조정한다
-  타임아웃 값: ACK 번호가 돌아오는 것을 기다리는 시간
- TCP는 대기 시간을 동적으로 변경함
##### 05 윈도우 제어 방식으로 효율적으로 ACK 번호를 관리한다
- 한 개의 패킷을 보낸 후 ACK 번호를 기다리지 않고 차례대로 연속해서 복수의 패킷을 보냄
- 수신측의 능력을 초과하여 패킷을 보낼 수도 있음
- 수신측에서 송신측에 수신 가능한 데이터 양을 통지
- ==수신측은 이 양을 초과하지 않도록 송신 동작 실행 -> 132쪽==
- 수신 처리를 통해 수신 버퍼에 빈 부분이 생기면 TCP 헤더의 윈도우 필드로 송신측에 알림
- 윈도우 사이즈: 수신 가능한 데이터 양의 최대값
##### 06 ACK 번호와 윈도우를 합승한다
- ==수신측에 통지할 필요가 없습니다 -> 134쪽==
- 수신측에서 애플리케이션에 데이터를 건네주고 수신 버퍼의 빈 영역이 늘어났을 때 이것을 송신측에 통지
- 패킷 수신 때마다 ACK 번호 통지 + 윈도우 통지 -> 효율성 저하
- 바로 보내지 않고 잠시 기다렸다가 함께 통지

##### 07 HTTP 응답 메시지를 수신한다
- 수신한 데이터 조각과 TCP 헤더의 내용을 조사하여 데이터 누락 점검
- 문제 없으면 ACK 번호 반송
- 데이터 조각을 수신 버퍼에 일시 보관
- 데이터 조각을 연결하여 복원 후 애플리케이션에 전달

## Story 04 서버에서 연결을 끊어 소켓을 말소한다

##### 01 데이터 보내기를 완료했을 때 연결을 끊는다
- 연결 끊기 동작에 먼저 들어가는 쪽에서 FIN을 1로 설정 후 송신
- 패킷을 받은 쪽에서 ACK 번호를 반송
- 서버에서 보낸 데이터를 전부 수신 완료하면 클라이언트도 종료
##### 02 소켓을 말소한다
- 오동작을 막기 위해 소켓은 잠시 기다린 후 말소
##### 03 데이터 송수신 동작을 정리한다

## Story 05 IP와 이더넷의 패킷 송수신 동작

##### 01 패킷의 기본
- TCP/IP의 패킷:
	- MAC 헤더 + IP 헤더 + TCP 헤더 + 데이터 조각
- IP가 목적지를 확인하여 다음 IP의 중계 장치를 나타냄
	- 라우터에는 IP용 표가 있음
	- 다음에 어느 라우터에 패킷을 중계할지 결정
- 서브넷 안에 있는 이더넷이 중계 장치까지 패킷을 운반함
	- 허브에는 패킷의 목적지를 판단하기 위한 표가 있음
	- 패킷의 목적지를 판단하여 중계
	- 이더넷은 IP의 의뢰를 받아 패킷을 운반할 수 있는 것이면 무엇이든지 그것으로 대체될 수 있음
		- ex) 무선 LAN, ADSL, FTTH
##### 02 패킷 송수신 동작의 개요
- IP 헤더: IP 프로토콜에 규정된 규칙에 따라 IP 주소로 표시된 목적지까지 패킷을 전달할 때 사용하는 제어 정보를 기록한 것
- MAC 헤더: 이더넷 등의 LAN을 사용하여 가장 가까운 라우터까지 패킷을 운반할 때 사용하는 제어 정보를 기록한 것
- TCP 담당 부분은 IP 담당 부분에게 데이터의 조각 + TPC 헤더를 건네줌
- IP 담당 부분은 IP 헤더와 MAC 헤더를 덧붙임
- IP 담당 부분은 헤더들을 덧붙인 패킷을 네트워크용 하드웨어(LAN 어댑터)에 건네줌
- LAN 어댑터에 의해 디지털 데이터가 전기나 빛의 신호 상태로 바뀌어 케이블에 송출됨
##### 03 수신처 IP 주소를 기록한 IP 헤더를 만든다
- 송수신처 IP 주소를 설정함
- 경로표(IP용 표)를 어느 LAN 어댑터에서 패킷을 송신해야 하는지 파악함
##### 04 이더넷용 MAC 헤더를 만든다
- 송수신처의 MAC 주소를 설정함
- 이더 타입으로 내용물이 무엇인지 나타냄
- 경로표에서 찾은 일치하는 행의 'Gateway' 항목에 기록되어 있는 IP 주소의 기기가 패킷을 건네줄 상대가 됨
##### 05 ARP로 수신처 라우터의 MAC 주소를 조사한다
- ARP를 조회하거나 ARP 캐시를 사용하여 수신처의 MAC 주소를 조사함
##### 06 이더넷의 기본
- 10BASE5(이더넷의 원형):
	- 케이블을 통해 모두에게 신호가 도착함
	- 수신처 주소에 해당하는 기기만 패킷을 수신함
- 스위칭 허브를 이용한 형태:
	- 수신처 MAC 주소에 따라 목적지를 확인하고 패킷 중계
	- 신호는 원하는 상태에게만 흐름
##### 07 IP 패킷을 전기나 빛의 신호로 변환하여 송신한다
- 디지털 데이터를 전기나 빛의 신호로 변환하여 네트워크의 케이블에 송출함
- LAN 어댑터가 동작하기 위해서는 LAN 드라이버 소프트웨어가 필요함
- LAN 어댑터의 ROM에는 전 세계에서 중복되지 않도록 일원화되어 관리되는 MAC 주소가 제조할 때 기록되어 있음
- LAN 어댑터에 기록된 MAC 주소는 LAN 드라이버가 MAC 회로에 설정함
##### 08 패킷에 3개의 제어용 데이터를 추가한다
- 패킷의 앞에는 프리앰블, 스타트 프레임 딜리미터를, 패킷의 뒤에는 프레임 체크 시퀀스를 부가함
- 스타트 프레임 딜리미터를 통해 타이밍에 맞게 클록 신호와 데이터 신호를 합쳐서 데이터 신호를 파악함
##### 09 허브를 향해 패킷을 송신한다
- 리피터 허브를 사용한 반이중 모드와 스위칭 허브를 사용한 전이중 모드가 있음
- 반이중 모드: 케이블에 신호가 정지했거나 흐르지 않고 있으면 송신 동작을 시작함
- LAN 어댑터의 MAC 회로가 공통 형식의 신호를 만들고 PHY(MAU) 회로가 케이블에 송출하는 형식으로 변환하여 케이블에 송신함
- 신호가 충동하면 재밍 신호를 보낸 후 잠시 후에 송신 동작을 재시도함
##### 10 돌아온 패킷을 받는다
- LAN 어댑터가 패킷을 받은 후 인터럽트를 통해 LAN 송수신 동작을 실행함
##### 11 서버의 응답 패킷을 IP에서 TCP로 넘긴다
- IP 주소가 일치하지 않으면 IP 담당 부분이 ICMP라는 메시지를 사용하여 상대에게 오류를 통지함
- 분할된 패킷이면 IP 담당 부분이 원래 패킷으로 되돌림(리어셈블링)
- TCP 담당 부분은 해당하는 알맞은 소켓을 찾아 적절한 동작을 수행함
## Story 06 UDP 프로토콜을 이용한 송수신 동작

##### 01 수정 송신이 필요없는 데이터의 송신은 UDP가 효율적이다
##### 02 제어용 짧은 데이터
- UDP 헤더: 송수신처 포트 번호, 데이터 길이, 체크섬
- 오류가 발생하여 회답이 돌아오지 않으면 데이터를 다시 보냄
##### 03 음성 및 동영상 데이터
- 데이터가 다소 없어도 치명적인 문제가 되지 않는 성질로 인해 UDP가 효과적임
