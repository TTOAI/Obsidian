
# Thread
- process의 execution state를 다른 것들로부터 분리
- program에서 일련의 instruction들을 수행함
- single-threaded process
	- 하나의 PC(program counter)를 가지고 있음
	- process는 완료될 때까지 한 번에 하나씩 순차적으로 intsruction들을 수행함
- multi-threaded process
	- thread마다 PC를 하나씩 가지고 있음
- thread들은 address space를 공유함
	- code, global variables, heap, opened files
	- ![[Pasted image 20241006164535.png]]
- thread마다 가지고 있는 것들
	- thread ID
	- set of registers including PC & SP
	- stack (thread끼리 서로의 stack에 접근 가능)
	- ![[Pasted image 20241006164553.png]]

# Process and Thread
- thread: the unit of scheduling, real dynamic entity
- process: static

# Concurrency vs. Parallelism
- concurrency: 하나의 core에서 여러 작업이 교차하며 실행
- parallelism: 여러 core를 사용하여 동시에 여러 작업 수행
- concurrency와 parallelism을 동시에 가질 수 있음

# Types of Parallelism
- data parallelism
	- 동일한 data의 subset들을 여러 core에 분산하고 동일한 작업을 수행함
	- ex) compute the sum of an array
- task parallelism
	- thread들을 여러 core에 분산하고 각 thread는 고유한 작업을 수행함
	- ex) compute the sum and standard deviation from different cores

# Amdahl's Law
- application에 추가적인 sysmtem resources를 추가함으로써 지연 시간에 성능 향상을 제공함
- process에 core를 추가할 때, parallelism이 향상됨
- program의 performance speed up 최대 계산
- ![[Pasted image 20241006170417.png]]
- ![[Pasted image 20241006170536.png]]

# Multithreading Models
- kernel threads
	- OS에 의해 직접 지원되고 관리됨
	- the unit of scheduling
- user threads
	- user-level threads libraries에 의해 생성되고 관리됨
	- user-level에서 구현됨
- One-to-One, Many-to-One, Many-to-Many, Two-level Model

# One-to-One
- ![[Pasted image 20241006171752.png]]
- 다른 모델들보다 더 많은 concurrency 제공
- overhead로 인해 process마다 thread의 개수에 제한이 있음
- ex) Linux, Windows, Solaris 9

# Many-to-One
- ![[Pasted image 20241006171953.png]]
- user thread 간 가볍고 빠른 context switch
- 하나의 thread blocking이 모든 thread를 block할 수 있음
- 커널에는 오직 하나의 스레드만 실행되기 때문에 multicore system에서 병렬처리가 불가능함, concurrency만 제공 가능

# Many-to-Many
- ![[Pasted image 20241006175005.png]]
- 여러 user-level thread를 여러 kernel thread에 다중 송신함
- OS가 충분한 개수의 kernel thread를 생성할 수 있게 함

# Two-level Model
- ![[Pasted image 20241006195941.png]]
- Many-to-Many model과 유사함
- user thread를 kernel thread에 독립적으로 바인딩할 수도 있음

# Thread Libraries
- programmer thread를 생성하고 관리할 수 있도록 API를 제공함
- ex) Pthreads, Windows, Java

# Pthreads
- thread 생성과 동기화를 위한 POSIX standard API
- thread library의 동작을 명시적으로 정의함
- 구현은 library의 개발에 따름
	- 우리는 구현이 아닌 명세에 초점을 맞춤
- UNIX 계열의 OS에 일반적

# Implicit Threading
- 컴파일러나 런타임 라이브러리가 자동으로 thread를 생성하고 관리하는 방식
- Thread Pools, Fork Join, OpenMP

# Thread Pools
- ![[Pasted image 20241006210550.png]]
- 미리 생성되어 대기하고 있는 여러 개의 thread들의 집합
- 새로운 thread를 생성하는 데 드는 시간을 줄여줌

# Fork Join
- ![[Pasted image 20241006212202.png]]
- 큰 작업을 작은 단위의 작업으로 분할하여 여러 thread에서 동시에 처리함
- main thread는 분할된 작업들이 완료되고 결합될 때까지 기다림

# OpenMP
- 공유 메모리 환경에서 병렬 프로그래밍을 지원하는 오픈 소스 API 및 컴파일러 지시어 집합
- parallel regions
	- ![[Pasted image 20241006212708.png]]
	- `#pragma omp parallel` 지시어로 시작하여 `}`로 끝나는 코드 블록
	- 이 블록 내의 코드는 여러 thread에서 동시에 실행될 수 있음

# Issues in Threads
- thread가 fork()를 호출했을 때
	- pthreads: calling thread만 복제함
	- UNIX international standard
		- fork(): 모든 부모 thread들을 child에 복제함
		- fork1(): calling thread만 복제함

# Signal Handling
- multi-threaded process에서 signal의 전달 위치
	- signal이 적용되는 thread에 signal 전달
		- synchronous signals
	- process의 모든 thread에 signal 전달
	- process의 특정 thread에 signal 전달
		- signal을 block하지 않은 thread
		- pthread: 특정 thread를 signal 처리기로 지정
	- process의 모든 signal을 수신하도록 특정 thread 지정
	- 수신자 중 하나가 시그널 처리

# Thread Cancellation
- asynchronous cancellation
	- 대상 thread를 즉시 종료
	- 대상 thread가 리소스를 보유하고 있거나 공유 리소스를 업데이트하는 중일 수 있음
		- 메무리 누수, 프로그램 오류 발생 가능
- deferred cancellation (지연 취소)
	- 대상 thread를 cancellation point에서 종료
		- 함수를 통한 취소 지점 설정
		- 일부 함수는 암시적으로 취소 지점 포함 (sleep(), wait(), read(), write())
	- 대상 thread는 주기적으로 취소돼야 하는지 확인
- Pthread API
	- 두 종류의 cancellation 모두 지원

# Thread-Local Storage (TLS)
- 각 스레드가 동일한 변수 이름으로 액세스할 수 있는 데이터의 자체 복사본을 갖도록 허용하는 메커니즘
- TLS 변수
	- 각 스레드마다 고유한 복사본이 있음
	- 한 스레드에서 TLS 변수를 변경해도 다른 스레드의 TLS 변수에는 영향을 미치지 않음
- Usecase 1: 동기화 걱정 없이 thread별 변수 사용에 용이
	- ![[Pasted image 20241006224649.png]]
	- 전역 변수 사용 시
		- 각 thread가 전역 변수에 접근할 때마다 다른 thread는 LOCK()에 의해 접근이 제한됨
		- 성능 저하 발생
	- TLS 사용 시
		- 각 thread는 TLS 변수를 사용하므로 LOCK()을 사용할 필요가 없음
		- 성능 저하 방지
- Usecase 2: errno 값 처리에 용이
	- ![[Pasted image 20241006230004.png]]
	- 함수 호출 시마다 errno를 전달하는 것은 번거로움
	- errno를 전역 변수로 사용하면 다른 thread에 의해 값이 덮어씌워질 수 있음
	- TLS에 errno 정의: 각 thread는 자신의 errno에 전역 변수처럼 접근하여 오류 코드를 읽을 수 있음

# Threads in Linux
- Linux에서 thread = task
- task_struct 구조체를 사용하여 task를 나타냄
- 새로운 thread를 생성하기 위해 clone() system call을 사용함
- clone()의 flags 인자를 사용하여 공유할 리소스를 지정할 수 있음
	- ![[Pasted image 20241007000111.png]]
